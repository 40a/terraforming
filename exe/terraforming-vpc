#!/usr/bin/env ruby

#
# terraforming-vpc
#
# Usage:
#   aws ec2 describe-vpcs | ./terraforming-vpc
#

require "json"

def vpc_name_of(vpc)
  name_tag = vpc['Tags'].find { |tag| tag['Key'] == "Name" }
  name_tag ? name_tag['Value'] : vpc['VpcId']
end

def tf(data)
  data['Vpcs'].inject([]) do |result, vpc|
    tags = vpc['Tags'].map do |tag|
      <<-EOS
        #{tag['Key']} = "#{tag['Value']}"
      EOS
    end.join("\n")

    result << <<-EOS
resource "aws_vpc" "#{vpc_name_of(vpc)}" {
    cidr_block       = "#{vpc['CidrBlock']}"
    instance_tenancy = "#{vpc['InstanceTenancy']}"

    tags {
#{tags}
    }
}
    EOS
  end.join("\n")
end

def tfstate(data)
  tfstate_db_instances = data['Vpcs'].inject({}) do |result, vpc|
    attributes = {
      "cidr_block" => vpc['CidrBlock'],
      "id" => vpc['VpcId'],
      "instance_tenancy" => vpc['InstanceTenancy'],
      "tags.#" => vpc['Tags'].length.to_s,
    }

    result["aws_vpc.#{vpc_name_of(vpc)}"] = {
      "type" => "aws_vpc",
      "primary" => {
        "id" => vpc['VpcId'],
        "attributes" => attributes
      }
    }
    result
  end

  JSON.pretty_generate(tfstate_db_instances)
end

generate_tfstate = ARGV.length > 0 && ARGV.shift == "--tfstate"

json = ARGF.read
data = JSON.parse(json)

puts generate_tfstate ? tfstate(data) : tf(data)
