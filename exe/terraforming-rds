#!/usr/bin/env ruby

#
# terraforming-rds
#
# Usage:
#   aws rds describe-db-instances | ./terraforming-rds
#

require "json"

def tf(data)
  data['DBInstances'].inject([]) do |result, instance|
    result << <<-EOS
resource "aws_db_instance" "#{instance['DBInstanceIdentifier']}" {
    identifier                = "#{instance['DBInstanceIdentifier']}"
    allocated_storage         = #{instance['AllocatedStorage']}
    storage_type              = "#{instance['StorageType']}"
    engine                    = "#{instance['Engine']}"
    engine_version            = "#{instance['EngineVersion']}"
    instance_class            = "#{instance['DBInstanceClass']}"
    name                      = "#{instance['DBName']}"
    username                  = "#{instance['MasterUsername']}"
    password                  = "xxxxxxxx"
    port                      = #{instance['Endpoint']['Port']}
    publicly_accessible       = #{instance['PubliclyAccessible']}
    availability_zone         = "#{instance['AvailabilityZone']}"
    vpc_security_group_ids    = #{instance['VpcSecurityGroups'].map { |sg| sg['VpcSecurityGroupId'] }.inspect}
    db_subnet_group_name      = "#{instance['DBSubnetGroup'] ? instance['DBSubnetGroup']['DBSubnetGroupName'] : ""}"
    parameter_group_name      = "#{instance['DBParameterGroups'][0]['DBParameterGroupName']}"
    multi_az                  = #{instance['MultiAZ']}
    backup_retention_period   = #{instance['BackupRetentionPeriod']}
    backup_window             = "#{instance['PreferredBackupWindow']}"
    maintenance_window        = "#{instance['PreferredMaintenanceWindow']}"
    final_snapshot_identifier = "#{instance['DBInstanceIdentifier']}-final"
}
    EOS
  end.join("\n")
end

def tfstate(data)
  tfstate_db_instances = data['DBInstances'].inject([]) do |result, instance|
    security_groups = {
      # TODO: key
      "security_group_names.#" => instance['DBSecurityGroups'].length.to_s
    }

    instance['DBSecurityGroups'].each do |security_group|
      security_groups["security_group_names.#{security_group['OptionGroupName']}"] = security_group['OptionGroupName']
    end

    vpc_security_groups = {
      "vpc_security_group_ids.#" => instance['VpcSecurityGroups'].length.to_s
    }

    instance['VpcSecurityGroups'].each do |vpc_security_group|
      # TODO: key
      security_groups["vpc_security_group_ids.#{vpc_security_group['VpcSecurityGroupId']}"] = vpc_security_group['VpcSecurityGroupId']
    end

    attributes = {
      "address" => instance['Endpoint']['Address'],
      "allocated_storage" => instance['AllocatedStorage'].to_s,
      "availability_zone" => instance['AvailabilityZone'],
      "backup_retention_period" => instance['BackupRetentionPeriod'].to_s,
      "backup_window" => instance['PreferredBackupWindow'],
      "db_subnet_group_name" => instance['DBSubnetGroup'] ? instance['DBSubnetGroup']['DBSubnetGroupName'] : "",
      "endpoint" => instance['Endpoint']['Address'],
      "engine" => instance['Engine'],
      "engine_version" => instance['EngineVersion'],
      "final_snapshot_identifier" => "#{instance['DBInstanceIdentifier']}-final",
      "id" => instance['DBInstanceIdentifier'],
      "identifier" => instance['DBInstanceIdentifier'],
      "instance_class" => instance['DBInstanceClass'],
      "maintenance_window" => instance['PreferredMaintenanceWindow'],
      "multi_az" => instance['MultiAZ'].to_s,
      "name" => instance['DBName'],
      "parameter_group_name" => instance['DBParameterGroups'][0]['DBParameterGroupName'],
      "password" => "xxxxxxxx",
      "port" => instance['Endpoint']['Port'].to_s,
      "publicly_accessible" => instance['PubliclyAccessible'].to_s,
      "status" => instance['DBInstanceStatus'],
      "storage_type" => instance['StorageType'],
      "username" => instance['MasterUsername'],
    }.merge(security_groups).merge(vpc_security_groups)

    tfstate_db_instance = {
      "aws_db_instance.#{instance['DBInstanceIdentifier']}" => {
        "type" => "aws_db_instance",
        "primary" => {
          "id" => instance['DBInstanceIdentifier'],
          "attributes" => attributes
        }
      }
    }

    result << tfstate_db_instance
    result
  end

  JSON.pretty_generate(tfstate_db_instances)
end

generate_tfstate = ARGV.length > 0 && ARGV.shift == "--tfstate"

json = ARGF.read
data = JSON.parse(json)

puts generate_tfstate ? tfstate(data) : tf(data)
